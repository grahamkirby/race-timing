/*
 * race-timing - <https://github.com/grahamkirby/race-timing>
 * Copyright Â© 2025 Graham Kirby (race-timing@kirby-family.net)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package org.grahamkirby.race_timing;


import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfReader;
import com.itextpdf.kernel.pdf.canvas.parser.PdfTextExtractor;
import org.grahamkirby.race_timing.common.RaceFactory;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.AnnotatedElementContext;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.io.CleanupMode;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.api.io.TempDirFactory;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.stream.Stream;

import static java.nio.file.FileVisitResult.CONTINUE;
import static org.grahamkirby.race_timing.common.Config.*;
import static org.junit.jupiter.api.Assertions.*;

@SuppressWarnings("preview")
public class RaceTest {

    // File names that may be present in list of expected output files for a given test, but should be ignored.
    private static final List<String> ignored_file_names = loadIgnoredFileNames();

    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Each test specifies a set of input files, located in test/resources, and checks either that the
    // expected output files are generated, or that the expected error occurs.
    //
    // If the DEBUG flag below is disabled then output files are generated within a temporary directory
    // and deleted at the end of each test.
    //
    // If DEBUG is enabled then output files are generated within a user-specified directory. If the
    // flag RETAIN_FIRST_OUTPUT is also enabled, then the output files generated by the first test are
    // retained for inspection at the end of the run. Otherwise, the output files generated by the
    // first failing test, if any, are retained.

    // TODO specify these in a config file.
    private static final boolean DEBUG = false;
    private static final boolean RETAIN_FIRST_OUTPUT = false;

    private static final String USER_TEST_DIRECTORY_PATH = "/Users/gnck/Desktop/tests";
    private static final String IGNORED_FILE_NAMES_PATH = "src/main/resources/configuration/test_ignored_file_names.csv";
    private static final String TEST_CONFIG_FILE_NAME = "config.txt";

    // Whether the current test is the first test in the run.
    private static boolean first_test = true;

    // Whether at least one test failed earlier in the run.
    @SuppressWarnings("BooleanVariableAlwaysNegated")
    private static boolean previous_failed_test = false;

    // Whether the current test failed.
    private boolean failed_test = true;

    //////////////////////////////////////////////////////////////////////////////////////////////////

    static {
        setLoggingLevel(DEBUG ? Level.INFO : Level.WARNING);
    }

    private Path config_file_path;
    private Path resources_input_directory;

    // Clean-up handled explicitly in tearDown().
    @TempDir(factory = TempFactory.class, cleanup = CleanupMode.NEVER)
    private Path test_directory;

    private Path test_input_directory;
    private Path test_output_directory;
    private Path retained_output_directory;
    private Path expected_output_directory;

    //////////////////////////////////////////////////////////////////////////////////////////////////

    @AfterEach
    public void tearDown() throws IOException {

        if (DEBUG) {

            // Whether this is the first test in the run to have failed.
            final boolean first_failed_test = failed_test && !previous_failed_test;

            // Whether the retained output directory is present from a previous run (in which case it should be deleted).
            final boolean output_directory_retained_from_previous_run = first_test && retained_output_directory != null && Files.exists(retained_output_directory);

            // Whether the output directory from this run should be retained, either because this is the first test
            // in the run to fail, or this is the first test in the run and RETAIN_FIRST_OUTPUT is set.
            final boolean output_directory_should_be_retained = first_failed_test || (first_test && RETAIN_FIRST_OUTPUT);

            // Delete the input and output directories but retain the parent test directory, to make it easier to
            // view the contents on repeated debugging runs.
            // Also retain a copy of the output directory for review if appropriate.
            cleanUpDirectories(output_directory_retained_from_previous_run, output_directory_should_be_retained);

            first_test = false;
            if (first_failed_test) previous_failed_test = true;

        } else
            deleteDirectory(test_directory);
    }

    private void cleanUpDirectories(final boolean output_directory_retained_from_previous_run, final boolean output_directory_should_be_retained) throws IOException {

        if (output_directory_retained_from_previous_run)
            deleteDirectory(retained_output_directory);

        if (output_directory_should_be_retained)
            copyDirectory(test_output_directory, retained_output_directory);

        deleteDirectory(test_input_directory);
        deleteDirectory(test_output_directory);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////

    @ParameterizedTest
    @MethodSource("getTestCases")
    public void testFromDirectories(final String test_directory_path_string) throws Exception {

        configureTest(test_directory_path_string);

        final String[] args = {config_file_path.toString()};

        final Path expected_error_message_file = expected_output_directory.resolve("expected_error_message.txt");

        if (!Files.exists(expected_error_message_file))
            runWithExpectedCompletion(args);
        else
            runWithExpectedError(args, expected_error_message_file);

        // Test has passed if this line is reached.
        failed_test = false;
    }

    @Test
    public void missingConfigFile() {

        // This omits the normal setup phase of copying the source and expected files.

        final String error_output;
        final String missing_config_path = "synthetic" + PATH_SEPARATOR + "special_cases" + PATH_SEPARATOR + "missing_config_file'";

        try {
            final ByteArrayOutputStream diverted_err = new ByteArrayOutputStream();
            System.setErr(new PrintStream(diverted_err));

            RaceFactory.main(new String[]{missing_config_path});

            error_output = diverted_err.toString();

        } finally {
            System.setErr(System.err);
        }

        assertEquals("missing config file: '" + missing_config_path + "'" + LINE_SEPARATOR,
            error_output,
            "Expected error message was not generated");

        // Test has passed if this line is reached.
        failed_test = false;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////

    private static List<String> getTestCases() throws IOException {

        final List<String> test_cases = new ArrayList<>();

        test_cases.addAll(getTestCasesWithin("real"));
        test_cases.addAll(getTestCasesWithin("synthetic"));

        return test_cases;
    }

    private static List<String> getTestCasesWithin(final String parent_test_directory) throws IOException {

        final Path parent_test_directory_path = getTestResourcesRootPath(parent_test_directory);

        try (final Stream<Path> paths = Files.list(parent_test_directory_path).sorted()) {

            final List<String> test_cases = new ArrayList<>();
            for (final Path test_directory_path : paths.toList()) {

                final String test_directory_path_string = Path.of(parent_test_directory).resolve(test_directory_path.getFileName()).toString();

                final Path test_resources_root_path = getTestResourcesRootPath(test_directory_path_string);
                if (Files.isDirectory(test_resources_root_path)) {

                    final boolean this_is_test_case_directory = Files.isDirectory(test_resources_root_path.resolve("expected"));

                    if (this_is_test_case_directory)
                        test_cases.add(test_directory_path_string);

                    test_cases.addAll(getTestCasesWithin(test_directory_path_string));
                }
            }
            return test_cases;
        }
    }

    private static Path getPathRelativeToProjectRoot(final String path) {

        return Path.of(path.substring(1));
    }

    private static Path getTestResourcesRootPath(final String individual_test_resource_root) {

        return getPathRelativeToProjectRoot("/src/test/resources/" + individual_test_resource_root);
    }

    private static void setLoggingLevel(final Level level) {

        final Logger root_logger = LogManager.getLogManager().getLogger("");
        root_logger.setLevel(level);
    }

    private void configureTest(final String individual_test_resource_root) throws IOException {

        configureDirectories(individual_test_resource_root);
        configureDirectoryContents(resources_input_directory);
    }

    private void runWithExpectedCompletion(final String[] args) throws IOException {

        runTest(args, "", "Unexpected error message");

        assertThatDirectoryContainsAllExpectedContent(expected_output_directory, test_output_directory);
    }

    private static void runWithExpectedError(final String[] args, final Path expected_error_message_file) throws IOException {

        final String expected_error_message = String.join(LINE_SEPARATOR, readAllLines(expected_error_message_file)) + LINE_SEPARATOR;

        runTest(args, expected_error_message, "Expected error message was not generated");
    }

    private static void runTest(final String[] args, final String expected_error_message, final String test_message) throws IOException {

        final String error_output;
        try {
            final ByteArrayOutputStream diverted_err = new ByteArrayOutputStream();
            System.setErr(new PrintStream(diverted_err));

            RaceFactory.main(args);

            error_output = diverted_err.toString();

        } finally {
            System.setErr(System.err);
        }

        assertEquals(expected_error_message, error_output, test_message);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////

    static class TempFactory implements TempDirFactory {

        @Override
        public Path createTempDirectory(final AnnotatedElementContext elementContext, final ExtensionContext extensionContext) throws Exception {

            if (DEBUG) {
                final Path temp_dir_path = Paths.get(USER_TEST_DIRECTORY_PATH);
                if (!Files.exists(temp_dir_path))
                    Files.createDirectory(temp_dir_path);
                return temp_dir_path;
            }

            return Files.createTempDirectory(null);
        }
    }

    private void configureDirectories(final String individual_test_resource_root) {

        final Path resources_root_directory = getTestResourcesRootPath(individual_test_resource_root);

        resources_input_directory = resources_root_directory.resolve("input");
        expected_output_directory = resources_root_directory.resolve("expected");

        test_input_directory = test_directory.resolve("input");
        test_output_directory = test_directory.resolve("output");
        retained_output_directory = test_directory.resolve("output_retained");

        config_file_path = test_input_directory.resolve(TEST_CONFIG_FILE_NAME);
    }

    private void configureDirectoryContents(final Path resources_inputs) throws IOException {

        Files.createDirectories(test_output_directory);
        if (Files.exists(test_input_directory)) deleteDirectory(test_input_directory);

        if (!Files.exists(resources_inputs))
            throw new RuntimeException("missing config file: '" + resources_inputs + "/" + TEST_CONFIG_FILE_NAME + "'");

        copyDirectory(resources_inputs, test_input_directory);
    }

    private static void assertThatDirectoryContainsAllExpectedContent(final Path expected, final Path actual) throws IOException {

        for (final String expected_file_name : getDirectoryEntries(expected)) {

            if (!shouldFileInExpectedDirectoryBeIgnored(expected_file_name)) {

                final Path path_expected = expected.resolve(expected_file_name);
                final Path path_actual = actual.resolve(expected_file_name);

                if (Files.isDirectory(path_expected)) {

                    assertTrue(Files.isDirectory(path_actual), "Expected directory missing");
                    assertThatDirectoryContainsAllExpectedContent(path_expected, path_actual);

                } else {
                    assertFalse(Files.isDirectory(path_actual), "Unexpected directory");
                    assertThatFilesHaveSameContent(path_expected, path_actual);
                }
            }
        }
    }

    private static List<String> getDirectoryEntries(final Path directory) throws IOException {

        try (final Stream<Path> list = Files.list(directory)) {
            return list.map(path -> path.getFileName().toString()).toList();
        }
    }

    private static void assertThatFilesHaveSameContent(final Path path1, final Path path2) {

        final List<String> file_content1 = getFileContent(path1);
        final List<String> file_content2 = getFileContent(path2);

        for (int i = 0; i < Math.min(file_content1.size(), file_content2.size()); i++) {
            assertEquals(file_content1.get(i), file_content2.get(i), LINE_SEPARATOR + "Difference in files: " + path1 + " and " + path2 + " at line " + (i + 1) + ":" + LINE_SEPARATOR +
                file_content1.get(i) + LINE_SEPARATOR + file_content2.get(i));
        }

        if (file_content1.size() < file_content2.size())
            assertThatLargerFileDoesNotContainFurtherNonBlankContent(path1, path2);
        if (file_content1.size() > file_content2.size())
            assertThatLargerFileDoesNotContainFurtherNonBlankContent(path2, path1);
    }

    private static void assertThatLargerFileDoesNotContainFurtherNonBlankContent(final Path path_smaller_file, final Path path_larger_file) {

        final List<String> content_smaller_file = getFileContent(path_smaller_file);
        final List<String> content_larger_file = getFileContent(path_larger_file);

        int i = content_smaller_file.size();
        while (i < content_larger_file.size() && content_larger_file.get(i).isBlank()) i++;

        if (i < content_larger_file.size())
            fail(LINE_SEPARATOR + "Difference in files: " + path_smaller_file + " and " + path_larger_file + ": at line " + (i + 1) + ":" + LINE_SEPARATOR + content_larger_file.get(i));
    }

    private static List<String> getFileContent(final Path path) {

        try {
            if (path.toString().endsWith(PDF_FILE_SUFFIX)) {
                try (final PdfDocument document = new PdfDocument(new PdfReader(path.toString()))) {

                    final List<String> contents = new ArrayList<>();
                    for (int i = 1; i <= document.getNumberOfPages(); i++)
                        contents.add(PdfTextExtractor.getTextFromPage(document.getPage(i)));

                    return contents;
                }
            } else return readAllLines(path);

        } catch (final IOException e) {
            fail("Error reading expected output file " + path + ": " + e);
            throw new RuntimeException(e);
        }
    }

    private static List<String> loadIgnoredFileNames() {

        try {
            return readAllLines(Path.of(IGNORED_FILE_NAMES_PATH)).stream().toList();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static boolean shouldFileInExpectedDirectoryBeIgnored(final String file_name) {
        return ignored_file_names.contains(file_name);
    }

    private static void copyDirectory(final Path source_directory, final Path destination_directory) throws IOException {

        Files.walkFileTree(source_directory, new SimpleFileVisitor<>() {

            @Override
            public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) throws IOException {

                Files.copy(dir, destination_directory.resolve(source_directory.relativize(dir)));
                return CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {

                Files.copy(file, destination_directory.resolve(source_directory.relativize(file)));
                return CONTINUE;
            }
        });
    }

    private static void deleteDirectory(final Path directory) throws IOException {

        if (directory != null && Files.isDirectory(directory))
            Files.walkFileTree(directory, new SimpleFileVisitor<>() {

                @Override
                public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {

                    Files.delete(dir);
                    return CONTINUE;
                }

                @Override
                public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {

                    Files.delete(file);
                    return CONTINUE;
                }
            });
    }
}
