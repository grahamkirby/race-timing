/*
 * Copyright 2024 Graham Kirby:
 * <https://github.com/grahamkirby/race-timing>
 *
 * This file is part of the module race-timing.
 *
 * race-timing is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * race-timing is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with race-timing. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package org.grahamkirby.race_timing;

import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfReader;
import com.itextpdf.kernel.pdf.canvas.parser.PdfTextExtractor;
import org.grahamkirby.race_timing.common.Race;
import org.junit.jupiter.api.AfterEach;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import static java.nio.file.FileVisitResult.CONTINUE;
import static org.junit.jupiter.api.Assertions.*;

public abstract class RaceTest {

    private static final Set<String> IGNORED_FILE_NAMES = Set.of(".DS_Store");

    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Each test specifies a set of input files, located in test/resources, and checks either that the
    // expected output files are generated, or that the expected error occurs.
    //
    // If the DEBUG flag below is disabled then output files are generated within a temporary directory
    // and deleted at the end of each test.
    //
    // If DEBUG is enabled then output files are generated within a user-specified directory, and the
    // output files generated by the first failing test are retained for inspection at the end of that
    // test.

    private static final boolean DEBUG = false;
    private static final String DEBUG_FILES_LOCATION = "/Users/gnck/Desktop/temp";
    private static final String TEMP_DIRECTORY_NAME = "temp";

    private static boolean some_previous_test_failed = false;
    private boolean test_failed = true;

    //////////////////////////////////////////////////////////////////////////////////////////////////

    private Path config_file_path;
    private Path resources_root_directory;
    private Path resources_input_directory;
    private Path temp_directory;
    private Path temp_input_directory;
    private Path temp_output_directory;
    private Path debug_output_directory;
    private Path expected_output_directory;

    protected abstract Race makeRace(Path config_file_path) throws IOException;

    //////////////////////////////////////////////////////////////////////////////////////////////////

    @AfterEach
    public void tearDown() throws IOException {

        if (DEBUG) {
            retainFirstFailedTestOutput();

            deleteDirectory(temp_input_directory);
            deleteDirectory(temp_output_directory);
        }
        else {
            deleteDirectory(temp_directory);
        }
    }

    private void retainFirstFailedTestOutput() throws IOException {

        if (!some_previous_test_failed) {

            if (Files.exists(debug_output_directory))
                deleteDirectory(debug_output_directory);

            if (test_failed) {
                copyDirectory(temp_output_directory, debug_output_directory);
                some_previous_test_failed = true;
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////

    protected void configureTest(final String individual_test_resource_root) throws IOException {

        temp_directory = DEBUG ? Paths.get(DEBUG_FILES_LOCATION) : Files.createTempDirectory(TEMP_DIRECTORY_NAME);

        configureDirectories(individual_test_resource_root);
        configureDirectoryContents(resources_input_directory);
    }

    protected void testExpectedException(final String configuration_name, final String expected_error_message) throws IOException {

        configureTest(configuration_name);

        final Exception thrown = assertThrows(
            RuntimeException.class,
            () -> makeRace(config_file_path).processResults()
        );

        assertEquals(expected_error_message, thrown.getMessage());

        test_failed = false;
     }

    protected void testExpectedCompletion(final String configuration_name) throws IOException {

        configureTest(configuration_name);
        makeRace(config_file_path).processResults();

        assertThatDirectoryContainsAllExpectedContent(expected_output_directory, temp_output_directory);

        test_failed = false;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////

    private void configureDirectories(final String individual_test_resource_root) {

        resources_root_directory = Race.getTestResourcesRootPath(individual_test_resource_root);

        resources_input_directory = resources_root_directory.resolve("input");
        expected_output_directory = resources_root_directory.resolve("expected");

        temp_input_directory = temp_directory.resolve("input");
        temp_output_directory = temp_directory.resolve("output");
        debug_output_directory = temp_directory.resolve("debug_output");

        config_file_path = temp_input_directory.resolve("config.txt");
    }

    private void configureDirectoryContents(final Path resources_inputs) throws IOException {

        Files.createDirectories(temp_output_directory);
        if (Files.exists(temp_input_directory)) deleteDirectory(temp_input_directory);

        copyDirectory(resources_inputs, temp_input_directory);
    }

    private static void assertThatDirectoryContainsAllExpectedContent(final Path expected, final Path actual) throws IOException {

        for (final String expected_file_name : getDirectoryEntries(expected)) {

            if (!fileInExpectedDirectoryShouldBeIgnored(expected_file_name)) {

                final Path path_expected = expected.resolve(expected_file_name);
                final Path path_actual = actual.resolve(expected_file_name);

                if (Files.isDirectory(path_expected)) {

                    assertTrue(Files.isDirectory(path_actual));
                    assertThatDirectoryContainsAllExpectedContent(path_expected, path_actual);
                }
                else {
                    assertFalse(Files.isDirectory(path_actual));
                    assertThatFilesHaveSameContentIgnoringWhitespace(path_expected, path_actual);
                }
            }
        }
    }

    private static List<String> getDirectoryEntries(final Path directory) throws IOException {

        try (final Stream<Path> list = Files.list(directory)) {
            return list.map(path -> path.getFileName().toString()).toList();
        }
    }

    private static void assertThatFilesHaveSameContentIgnoringWhitespace(final Path path1, final Path path2) throws IOException {

        final String file_content1 = removeWhiteSpace(getFileContent(path1));
        final String file_content2 = removeWhiteSpace(getFileContent(path2));

        if (!file_content1.equals(file_content2))
            fail("Files differ: " + path1 + ", " + path2);
    }

    private static String getFileContent(final Path path) throws IOException {

        if (!path.toString().endsWith(".pdf"))
            return Files.readAllLines(path).stream().reduce(String::concat).orElseThrow();

        else {

            try (final PdfDocument document = new PdfDocument(new PdfReader(path.toString()))) {

                final StringBuilder text = new StringBuilder();
                for (int i = 1; i <= document.getNumberOfPages(); i++)
                    text.append(PdfTextExtractor.getTextFromPage(document.getPage(i)));

                return text.toString();
            }
        }
    }

    private static String removeWhiteSpace(final String s) {
        return s.replaceAll("\t", "").replaceAll("\n", "").replaceAll(" ", "");
    }

    private static boolean fileInExpectedDirectoryShouldBeIgnored(final String file_name) {
        return IGNORED_FILE_NAMES.contains(file_name);
    }

    private static void copyDirectory(final Path source_directory, final Path destination_directory) throws IOException {

        Files.walkFileTree(source_directory, new SimpleFileVisitor<>() {

            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes ignore) throws IOException {

                Files.copy(dir, destination_directory.resolve(source_directory.relativize(dir)));
                return CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes ignore) throws IOException {

                Files.copy(file, destination_directory.resolve(source_directory.relativize(file)));
                return CONTINUE;
            }
        });
    }

    private static void deleteDirectory(final Path directory) throws IOException {

        Files.walkFileTree(directory, new SimpleFileVisitor<>() {

            @Override
            public FileVisitResult postVisitDirectory(final Path dir, final IOException ignore) throws IOException {

                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(final Path file, final BasicFileAttributes ignore) throws IOException {

                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
